grammar;

use aleph_syntax_tree::syntax::AlephTree as at;

// Top-level program parser producing a Module
pub Program: at = {
    <defs:Definitions> => at::Module {
        name: "FORTH_PROGRAM".to_string(),
        module_type: "program".to_string(),
        id: None,
        declarations: defs,
        body: None,
        initialization: None,
    },
}

// Non-empty vector of definitions
pub Definitions: Vec<Box<at>> = {
    <def:Definition> => vec![Box::new(def)],
    <defs:Definitions> <def:Definition> => {
        let mut v = defs;
        v.push(Box::new(def));
        v
    }
}

// Single Forth definition (constant, variable, word, create, comment)
pub Definition: at = {
    WordDefinition,
    ConstantDef,
    VariableDef,
    CreateDef,
    Comment,
}

// Colon definition ": foo ... ;" - uses generic ProcedureDef with proc_type = "word"
WordDefinition: at = {
    ":" <name:Ident> <body:WordBody> ";" => at::ProcedureDef {
        name,
        proc_type: Some("word".to_string()),
        parameters: vec![],
        return_type: None,
        attributes: vec![],
        declarations: vec![],
        body,
    }
}

// Body of a word is a sequence of WordItems
pub WordBody: Vec<Box<at>> = {
    <word:WordItem> => vec![Box::new(word)],
    <body:WordBody> <word:WordItem> => {
        let mut v = body;
        v.push(Box::new(word));
        v
    }
}

// Single word item - produces AST nodes matching AlephTree variants
WordItem: at = {
    Number,
    StringLiteral,
    Word,
    StackOp,
    ArithOp,
    CompareOp,
    LogicOp,
    MemoryOp,
    IOOp,
    ControlStruct,
    Comment,
}

// Constants "42 CONSTANT name" - uses generic VarDecl with is_constant = true
ConstantDef: at = {
    <val:Number> "CONSTANT" <name:Ident> => at::VarDecl {
        name,
        level: None,
        var_type: None,
        initial_value: Some(Box::new(val)),
        is_constant: true,
        is_aliased: false,
        storage: None,
        occurs: None,
        usage: None,
        attributes: vec!["forth_constant".to_string()],
    }
}

// Variables "VARIABLE name" - uses generic VarDecl
VariableDef: at = {
    "VARIABLE" <name:Ident> => at::VarDecl {
        name,
        level: None,
        var_type: None,
        initial_value: None,
        is_constant: false,
        is_aliased: false,
        storage: None,
        occurs: None,
        usage: None,
        attributes: vec!["forth_variable".to_string()],
    }
}

// CREATE ... [AllotClause] [DOES> WordBody] - uses generic CreateDoes
CreateDef: at = {
    "CREATE" <name:Ident> ";" => at::CreateDoes {
        name,
        allot_size: None,
        does_body: None
    },
    "CREATE" <name:Ident> <allot:AllotClause> ";" => at::CreateDoes {
        name,
        allot_size: Some(Box::new(allot)),
        does_body: None
    },
    "CREATE" <name:Ident> "DOES>" <body:WordBody> ";" => at::CreateDoes {
        name,
        allot_size: None,
        does_body: Some(body)
    },
    "CREATE" <name:Ident> <allot:AllotClause> "DOES>" <body:WordBody> ";" => at::CreateDoes {
        name,
        allot_size: Some(Box::new(allot)),
        does_body: Some(body)
    },
}

// AllotClause is either "Number ALLOT" or "Number CELLS ALLOT"
AllotClause: at = {
    <n:Number> "ALLOT" => n,
    <n:Number> "CELLS" "ALLOT" => at::MemoryOp { 
        operation: "cells".to_string(), 
        args: vec![Box::new(n)] 
    },
}

// Number literal covers Int, Float, Hex
Number: at = {
    Integer,
    Float,
    HexNumber,
}

// Integer literal - uses generic Int
Integer: at = r"-?[0-9]+" => at::Int { value: <>.to_string() };

// Float literal - uses generic Float
Float: at = r"-?[0-9]+\.[0-9]+" => at::Float { value: <>.to_string() };

// Hex number literal - uses generic HexLiteral
HexNumber: at = r"0[xX][0-9A-Fa-f]+" => at::HexLiteral { value: <>.to_string() };

// String literals for ." ... " and S" ... "
StringLiteral: at = {
    r#"\." [^"]* ""# => {
        let s = <>.to_string();
        let text = s.trim_start_matches(".\"").trim_end_matches('"').trim();
        at::Emit { 
            value: Box::new(at::String { value: text.to_string() }),
            emit_type: Some("string".to_string())
        }
    },
    r#"S" [^"]* ""# => {
        let s = <>.to_string();
        let text = s.trim_start_matches("S\"").trim_end_matches('"').trim();
        at::String { value: text.to_string() }
    }
}

// Word reference - uses generic Ident
Word: at = {
    <name:Ident> => at::Ident { value: name }
}

// Stack operations - uses generic StackOp
StackOp: at = {
    "DUP" => at::StackOp { operation: "dup".to_string(), args: vec![] },
    "DROP" => at::StackOp { operation: "drop".to_string(), args: vec![] },
    "SWAP" => at::StackOp { operation: "swap".to_string(), args: vec![] },
    "OVER" => at::StackOp { operation: "over".to_string(), args: vec![] },
    "ROT" => at::StackOp { operation: "rot".to_string(), args: vec![] },
    "-ROT" => at::StackOp { operation: "-rot".to_string(), args: vec![] },
    "NIP" => at::StackOp { operation: "nip".to_string(), args: vec![] },
    "TUCK" => at::StackOp { operation: "tuck".to_string(), args: vec![] },
    "PICK" => at::StackOp { operation: "pick".to_string(), args: vec![Box::new(at::Unit)] },
    "ROLL" => at::StackOp { operation: "roll".to_string(), args: vec![Box::new(at::Unit)] },
    "2DUP" => at::StackOp { operation: "2dup".to_string(), args: vec![] },
    "2DROP" => at::StackOp { operation: "2drop".to_string(), args: vec![] },
    "2SWAP" => at::StackOp { operation: "2swap".to_string(), args: vec![] },
    "2OVER" => at::StackOp { operation: "2over".to_string(), args: vec![] },
    ">R" => at::StackOp { operation: ">r".to_string(), args: vec![] },
    "R>" => at::StackOp { operation: "r>".to_string(), args: vec![] },
    "R@" => at::StackOp { operation: "r@".to_string(), args: vec![] },
    "I" => at::Var { var: "i".to_string(), is_pointer: "false".to_string() },
    "J" => at::Var { var: "j".to_string(), is_pointer: "false".to_string() },
    "LEAVE" => at::Break
}

// Arithmetic operations - uses generic arithmetic nodes
ArithOp: at = {
    "+" => at::Add {
        number_expr1: Box::new(at::Unit),
        number_expr2: Box::new(at::Unit)
    },
    "-" => at::Sub {
        number_expr1: Box::new(at::Unit),
        number_expr2: Box::new(at::Unit)
    },
    "*" => at::Mul {
        number_expr1: Box::new(at::Unit),
        number_expr2: Box::new(at::Unit)
    },
    "/" => at::Div {
        number_expr1: Box::new(at::Unit),
        number_expr2: Box::new(at::Unit)
    },
    "MOD" => at::Mod {
        number_expr1: Box::new(at::Unit),
        number_expr2: Box::new(at::Unit)
    },
    "/MOD" => at::DivMod {
        dividend: Box::new(at::Unit),
        divisor: Box::new(at::Unit)
    },
    "*/" => at::MulDiv {
        n1: Box::new(at::Unit),
        n2: Box::new(at::Unit),
        n3: Box::new(at::Unit)
    },
    "*/MOD" => at::MulDivMod {
        n1: Box::new(at::Unit),
        n2: Box::new(at::Unit),
        n3: Box::new(at::Unit)
    },
    "1+" => at::Add {
        number_expr1: Box::new(at::Unit),
        number_expr2: Box::new(at::Int { value: "1".to_string() })
    },
    "1-" => at::Sub {
        number_expr1: Box::new(at::Unit),
        number_expr2: Box::new(at::Int { value: "1".to_string() })
    },
    "2*" => at::Mul {
        number_expr1: Box::new(at::Unit),
        number_expr2: Box::new(at::Int { value: "2".to_string() })
    },
    "2/" => at::Div {
        number_expr1: Box::new(at::Unit),
        number_expr2: Box::new(at::Int { value: "2".to_string() })
    },
    "ABS" => at::Abs { expr: Box::new(at::Unit) },
    "NEGATE" => at::Neg { expr: Box::new(at::Unit) },
    "MIN" => at::Min {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Unit)
    },
    "MAX" => at::Max {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Unit)
    }
}

// Comparison operators - uses generic comparison nodes
CompareOp: at = {
    "=" => at::Eq {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Unit)
    },
    "<>" => at::NotEq {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Unit)
    },
    "<" => at::LT {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Unit)
    },
    ">" => at::GT {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Unit)
    },
    "<=" => at::LE {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Unit)
    },
    ">=" => at::GE {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Unit)
    },
    "0=" => at::Eq {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Int { value: "0".to_string() })
    },
    "0<>" => at::NotEq {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Int { value: "0".to_string() })
    },
    "0<" => at::LT {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Int { value: "0".to_string() })
    },
    "0>" => at::GT {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Int { value: "0".to_string() })
    }
}

// Logic operators - uses generic bitwise nodes
LogicOp: at = {
    "AND" => at::BitAnd {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Unit)
    },
    "OR" => at::BitOr {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Unit)
    },
    "XOR" => at::BitXor {
        expr1: Box::new(at::Unit),
        expr2: Box::new(at::Unit)
    },
    "INVERT" => at::BitNot { expr: Box::new(at::Unit) },
    "LSHIFT" => at::LShift {
        expr: Box::new(at::Unit),
        amount: Box::new(at::Unit)
    },
    "RSHIFT" => at::RShift {
        expr: Box::new(at::Unit),
        amount: Box::new(at::Unit)
    }
}

// Memory operators - uses generic Fetch/Store and MemoryOp
MemoryOp: at = {
    "@" => at::Fetch {
        addr: Box::new(at::Unit),
        fetch_type: Some("cell".to_string())
    },
    "!" => at::Store {
        value: Box::new(at::Unit),
        addr: Box::new(at::Unit),
        store_type: Some("cell".to_string())
    },
    "+!" => at::StoreOp {
        value: Box::new(at::Unit),
        addr: Box::new(at::Unit),
        op: "+".to_string()
    },
    "C@" => at::Fetch {
        addr: Box::new(at::Unit),
        fetch_type: Some("byte".to_string())
    },
    "C!" => at::Store {
        value: Box::new(at::Unit),
        addr: Box::new(at::Unit),
        store_type: Some("byte".to_string())
    },
    "CELLS" => at::MemoryOp { 
        operation: "cells".to_string(), 
        args: vec![Box::new(at::Unit)] 
    },
    "ALLOT" => at::MemoryOp { 
        operation: "allot".to_string(), 
        args: vec![Box::new(at::Unit)] 
    },
    "," => at::DataOp { 
        operation: "comma".to_string(), 
        value: Box::new(at::Unit) 
    },
    "C," => at::DataOp { 
        operation: "c-comma".to_string(), 
        value: Box::new(at::Unit) 
    },
    "HERE" => at::MemoryOp { 
        operation: "here".to_string(), 
        args: vec![] 
    }
}

// I/O operations - uses generic Emit and Input nodes
IOOp: at = {
    "." => at::Emit { 
        value: Box::new(at::Unit), 
        emit_type: Some("number".to_string()) 
    },
    "EMIT" => at::Emit { 
        value: Box::new(at::Unit), 
        emit_type: Some("char".to_string()) 
    },
    "CR" => at::Emit { 
        value: Box::new(at::String { value: "\n".to_string() }), 
        emit_type: Some("string".to_string()) 
    },
    "SPACE" => at::Emit { 
        value: Box::new(at::String { value: " ".to_string() }), 
        emit_type: Some("string".to_string()) 
    },
    "SPACES" => at::Emit { 
        value: Box::new(at::Unit), 
        emit_type: Some("spaces".to_string()) 
    },
    "KEY" => at::Input { 
        targets: vec![],
        source: None,
        options: vec!["key".to_string()]
    },
    "TYPE" => at::Print {
        items: vec![Box::new(at::Unit)],
        destination: None,
        format: None,
        options: vec!["type".to_string()]
    },
    "ACCEPT" => at::Input {
        targets: vec![Box::new(at::Unit)],
        source: None,
        options: vec!["accept".to_string()]
    }
}

// Control structures
ControlStruct: at = {
    IfThen,
    IfElseThen,
    BeginUntil,
    BeginWhileRepeat,
    BeginAgain,
    DoLoop,
    DoPlusLoop,
    CaseStruct
}

// IF ... THEN - uses generic If node
IfThen: at = {
    "IF" <then:WordBody> "THEN" => at::If {
        condition: Box::new(at::Unit),
        then: Box::new(at::Block { statements: then }),
        els: Box::new(at::Unit)
    }
}

// IF ... ELSE ... THEN - uses generic If node
IfElseThen: at = {
    "IF" <then:WordBody> "ELSE" <els:WordBody> "THEN" => at::If {
        condition: Box::new(at::Unit),
        then: Box::new(at::Block { statements: then }),
        els: Box::new(at::Block { statements: els })
    }
}

// BEGIN ... UNTIL - uses generic DoLoop with until_cond
BeginUntil: at = {
    "BEGIN" <body:WordBody> "UNTIL" => at::DoLoop {
        loop_var: None,
        start: None,
        end: None,
        by: None,
        while_cond: None,
        until_cond: Some(Box::new(at::Unit)),
        body
    }
}

// BEGIN ... WHILE ... REPEAT - uses generic DoLoop with while_cond
BeginWhileRepeat: at = {
    "BEGIN" <while_body:WordBody> "WHILE" <repeat_body:WordBody> "REPEAT" => at::DoLoop {
        loop_var: None,
        start: None,
        end: None,
        by: None,
        while_cond: Some(Box::new(at::Unit)),
        until_cond: None,
        body: {
            let mut combined = while_body;
            combined.extend(repeat_body);
            combined
        }
    }
}

// BEGIN ... AGAIN - uses generic Loop
BeginAgain: at = {
    "BEGIN" <body:WordBody> "AGAIN" => at::Loop { 
        name: None, 
        body 
    }
}

// DO ... LOOP - uses generic DoLoop
DoLoop: at = {
    "DO" <body:WordBody> "LOOP" => at::DoLoop {
        loop_var: None,
        start: Some(Box::new(at::Unit)),
        end: Some(Box::new(at::Unit)),
        by: None,
        while_cond: None,
        until_cond: None,
        body
    }
}

// DO ... +LOOP - uses generic DoLoop with increment
DoPlusLoop: at = {
    "DO" <body:WordBody> "+LOOP" => at::DoLoop {
        loop_var: None,
        start: Some(Box::new(at::Unit)),
        end: Some(Box::new(at::Unit)),
        by: Some(Box::new(at::Unit)),
        while_cond: None,
        until_cond: None,
        body
    }
}

// CASE ... ENDCASE - uses generic Case node
CaseStruct: at = {
    "CASE" <clauses:OfClauses> "ENDCASE" => at::Case {
        expr: Box::new(at::Unit),
        cases: clauses,
        default_case: None
    },
    "CASE" <clauses:OfClauses> <default:WordBody> "ENDCASE" => at::Case {
        expr: Box::new(at::Unit),
        cases: clauses,
        default_case: Some(Box::new(at::Block { statements: default }))
    }
}

// List of OF clauses
OfClauses: Vec<Box<at>> = {
    <clause:OfClause> => vec![Box::new(clause)],
    <clauses:OfClauses> <clause:OfClause> => {
        let mut v = clauses;
        v.push(Box::new(clause));
        v
    }
}

// OF ... ENDOF clause - uses generic CaseBranch
OfClause: at = {
    "OF" <body:WordBody> "ENDOF" => at::CaseBranch {
        pattern: Box::new(at::Unit),
        body
    }
}

// Comments - uses generic Comment node
Comment: at = {
    r"\([^)]*\)" => {
        let text = <>.to_string()
            .trim_start_matches('(')
            .trim_end_matches(')')
            .trim()
            .to_string();
        at::Comment { value: text }
    },
    r"\\[^\n]*" => {
        let text = <>.to_string()
            .trim_start_matches('\\')
            .trim()
            .to_string();
        at::Comment { value: text }
    }
}

// Identifier token
Ident: String = r"[a-zA-Z_][a-zA-Z0-9_\-+*/<>=?!@#$%&]*" => <>.to_string();
